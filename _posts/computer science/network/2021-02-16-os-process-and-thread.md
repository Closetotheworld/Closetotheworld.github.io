---
title: "프로세스의 이해"

categories:
  - OS
tags:
  - [CS, interview]

toc: true
toc_sticky: true

last_modified_at: 2021-02-16T02:00:00
---

## &#10067; 프로세스(program in excution)

실행중인 프로그램을 `프로세스`라고 한다.

- 운영체제 입장에서는 `작업의 단위`
- 한 프로세스가 실행이 되기 위해서는 자원이 필요함.
  - CPU time
  - memory
  - files
  - I/O device

보통 실행 파일을 작성하면 hdd 등의 저장장치에 저장이 된다.  
이를 보통 바로 cpu로 끌고와서 실행하지는 못하는데, 과정은 다음과 같다.  
저장장치에 있는 메모리 집합을 메모리에 올리게 된다. -> 이 과정에서 있는 것이 process이다.
이후 이 process가 cpu를 점유하여야 실행이 된다.

## &#10067; 프로세스 concept

### &#10071; 프로세스 메모리의 구성

- 프로세스 메모리의 구성은 여러개의 구역으로 나누어 져 있다.

  - `text section` -> 실행가능한 코드
  - `data section` -> 전역변수
  - `heap section` -> 런타임에서 동적으로 할당된 메모리 (malloc, new 등)
  - `stack section` -> 함수가 호출되었을때의 데이터 스토리지이다. (함수 파라미터, 반환주소, 지역변수 등)

### &#10071; 프로세스 생명주기

- New : 프로세스가 생성이 되었을 때
- Running : 명령어집합들이 실행이 되고 있을 때
- Waiting : I/O같은 경우에서 waiting상태로 들어감 -> 어떤 이벤트가 발생할 때 까지 프로세스가 기다린다!
- Ready : I/O를 대기하다가 작업이 끝났다고 signal이 온다 해도 CPU 정리를 바로 하지 못한다. 따라서 Ready Queue로 돌아가서 나는 이제 CPU를 받아도 된다! 라고 준비하는 상태
- Terminated : 모든것이 종료된 상태.

상태 다이어그램은 다음과 같다.

1. fork()를 통한 `New` 상태
2. Ready Queue로 들어간 `Ready` 상태 (나는 이제 CPU를 받아서 일할 상태가 되어있어!)
   - 이후 운영체제가 CPU를 준다.
3. CPU를 받게 된 Process는 `Running` 상태가 된다
   - 작업 진행 중 너무 오래 점유를 하면 운영체제가 좀 쉬라고 한다. (1)
   - 작업 진행 중 I/O가 발생했다! (2)
4. (1) 다시 `Ready`로 돌아와 작업을 쉬게 된다.
5. (2) 자발적으로 `Running`에서 나가서 `waiting`으로 돌아간다.(I/O 중에는 내가 할 일이 없다!)
   - 이후 I/O가 끝나게 되면 `Ready`로 돌아오게 된다.
6. 다시 `Running`으로 돌아온다.(이를 scheduler dispatch라 한다!)
7. `Running` 중 `exit` 혹은 _main_ 에서 `return`을 하게 되면 `terminated` 상태로 돌아가며 종료가 된다.

### &#10071; Process Control Block(PCB)

구조체 안에다가 프로세스에 필요요한 걸 다 저장하자! 라는 것

- PCB를 가지고 프로세스를 핸들링 한다.
- PCB가 가지고 있는 정보는 너무 많지만, 중요한 것은 다음과 같음

  - 현재 프로세스의 상태(new, running, waiting, ready, terminated)
  - 프로세스 카운터(메모리에서 명령어를 fetch하는데 몇 번지에서 가져올거야? -> PC register에 해당하는 레지스터!)
  - CPU 레지스터
  - CPU 스케쥴링 정보(CPU를 주거나 릴리즈하기 위한 정보)
  - 메모리 관리 정보(malloc을 얼마나 했고 ~)
  - 계정 정보(어떤 유저가 만든 process인지?)
  - I/O status 정보(어떤 장보를 오픈하고 닫고 했는지 정보)

- 위와 같은 정보들을 구조체에 담아 struct로 만듬. 이 하나의 단위가 PCB이다.

### &#10071; 프로세스 스케쥴링

- 동시에 여러개의 프로세스를 실행시켜보자!(병렬적인 것과는 차이가 있음)

  - CPU의 사용 효율을 최대화 하기 때문에!

- time sharing의 목적

  - CPU 코어를 프로세스 간 자주 바꾸어서 사용자 입장에서는 각 프로그램이 동시에 Running 중인 것 마냥 보이게 하는 것!

- 스케쥴링 큐

  - 대기열(`ready queue`)에 대기중인 프로세스가 준비가 되면 순서대로 CPU에 인입된다.
  - 위에서 설명했듯이 시간이 끝나면 다시 `Ready`로 돌아가는데, `Waiting`으로 가는 경우도 있다고 설명했다.
  - 링크드리스트로 구현을 해볼 수 있다.

- 문맥 교환(context switch)
  - context : 프로세스의 입장에서 프로세스가 사용되고 있는 상태라 할 수 있음 -> PCB에 저장되어있는!
  - 인터럽트가 일어난다면?
    - 현재 context를 저장(PC 카운터 중요) -> 다시 CPU를 획득했을 때(context를 다시 불러옴)
  - 결국 문맥교환이란?
    - CPU 코어를 다른 프로세스에다 넘겨주는 것.
    - 현재 프로세스의 context를 저장 / 새로운 프로세스의 context를 복원!

### &#10071; 프로세스의 관리

- 결국 운영체제는 프로세스를 생성, 종료하는 데에 관여한다는 것을 알 수 있다.
- 하지만 프로세스도 새 프로세스를 만들 수 있다.

  - `부모 프로세스` - `자식 프로세스` 관계

- fork를 통해 프로세스가 생성이 됨.

  - concurrent하게 실행되는 상태일 수 있음(부모와 자식이 같이 실행이 됨)
  - 부모는 기다리는 상태가 될 수 있음.(자식이 terminated 될 때 까지 부모는 대기)

- 또한 주소적 측면도 두 가지가 있음.

  - 자식 프로세스가 주소공간을 복제해서 쓰는 경우
  - 새로운 공간을 만들어 사용하는 경우

- 그러면 종료는 어떻게?

  - 보통 마지막 `return`해서 끝나는 문장을 마주했을 때 `terminated`가 된다.
  - 또는 `exit()`를 호출한다.
  - OS는 메모리를 해제하고 자원을 회수한다.(할당메모리, 열린 파일, I/O 버퍼 등)

- 좀비상태? 기아상태?

  - 부모는 나름대로 뭔가 따로 하고, 자식도 뭔가 따로한다. -> 좀비 프로세스(데몬 프로세스)
  - 부모 프로세스가 wait()를 안하고 자식이 끝나던 말던 내가먼저 끝남 -> 기아 프로세스

  &#128526;
  &#10060;
